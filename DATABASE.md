# Database Design Documentation

## a) Database Design

This application uses **MongoDB**, a NoSQL document database. While MongoDB doesn't use traditional tables, we have three main collections that function similarly to tables in a relational database.

### Collections (Tables)

#### 1. Users Collection
```javascript
{
  _id: ObjectId,              // Primary Key (auto-generated by MongoDB)
  username: String,           // Unique
  password: String,
  email: String,              // Unique
  createdAt: Date
}
```

**Primary Key:** `_id` (ObjectId)

**Indexes:**
- `username` (unique)
- `email` (unique)

---

#### 2. Classes Collection
```javascript
{
  _id: ObjectId,              // Primary Key (auto-generated by MongoDB)
  name: String,
  description: String,
  userId: ObjectId,           // Foreign Key → references Users._id
  createdAt: Date
}
```

**Primary Key:** `_id` (ObjectId)

**Foreign Keys:**
- `userId` → References `Users._id`
  - Relationship: One User can have many Classes (One-to-Many)
  - On User delete: Classes should be deleted (cascade delete)

---

#### 3. Tasks Collection
```javascript
{
  _id: ObjectId,              // Primary Key (auto-generated by MongoDB)
  name: String,
  description: String,
  classId: ObjectId,          // Foreign Key → references Classes._id
  estimatedTime: Number,      // in minutes
  dueDate: Date,
  completed: Boolean,
  priority: String,           // enum: ['low', 'medium', 'high']
  createdAt: Date
}
```

**Primary Key:** `_id` (ObjectId)

**Foreign Keys:**
- `classId` → References `Classes._id`
  - Relationship: One Class can have many Tasks (One-to-Many)
  - On Class delete: Tasks should be deleted (cascade delete)

---

### Entity-Relationship Diagram (Text Format)

```
┌──────────────┐
│    Users     │
├──────────────┤
│ _id (PK)     │
│ username     │
│ password     │
│ email        │
│ createdAt    │
└──────┬───────┘
       │
       │ 1:N (One User has many Classes)
       │
       ▼
┌──────────────┐
│   Classes    │
├──────────────┤
│ _id (PK)     │
│ name         │
│ description  │
│ userId (FK)  │
│ createdAt    │
└──────┬───────┘
       │
       │ 1:N (One Class has many Tasks)
       │
       ▼
┌──────────────┐
│    Tasks     │
├──────────────┤
│ _id (PK)     │
│ name         │
│ description  │
│ classId (FK) │
│ estimatedTime│
│ dueDate      │
│ completed    │
│ priority     │
│ createdAt    │
└──────────────┘
```

---

## b) Insert, Update, and Delete Operations

Here are examples of how to perform CRUD operations on the **Classes** collection:

### INSERT (Create)
```javascript
// API Endpoint: POST /api/classes
// Request Body:
{
  "name": "CS348 - Database Systems",
  "description": "Introduction to database design and SQL"
}

// Backend Code (routes/classes.js):
const classItem = new Class({
  name: req.body.name,
  description: req.body.description,
  userId: req.body.userId || '000000000000000000000000'
});
const newClass = await classItem.save();

// MongoDB Command Equivalent:
db.classes.insertOne({
  name: "CS348 - Database Systems",
  description: "Introduction to database design and SQL",
  userId: ObjectId("000000000000000000000000"),
  createdAt: new Date()
});
```

### UPDATE
```javascript
// API Endpoint: PUT /api/classes/:id
// Request Body:
{
  "name": "CS348 - Advanced Databases",
  "description": "Advanced topics in database systems"
}

// Backend Code (routes/classes.js):
const classItem = await Class.findById(req.params.id);
if (req.body.name != null) {
  classItem.name = req.body.name;
}
if (req.body.description != null) {
  classItem.description = req.body.description;
}
const updatedClass = await classItem.save();

// MongoDB Command Equivalent:
db.classes.updateOne(
  { _id: ObjectId("507f1f77bcf86cd799439011") },
  { 
    $set: { 
      name: "CS348 - Advanced Databases",
      description: "Advanced topics in database systems"
    }
  }
);
```

### DELETE
```javascript
// API Endpoint: DELETE /api/classes/:id

// Backend Code (routes/classes.js):
const classItem = await Class.findById(req.params.id);
// Cascade delete: Also delete all tasks associated with this class
await Task.deleteMany({ classId: req.params.id });
await Class.findByIdAndDelete(req.params.id);

// MongoDB Command Equivalent:
// First delete associated tasks
db.tasks.deleteMany({ classId: ObjectId("507f1f77bcf86cd799439011") });
// Then delete the class
db.classes.deleteOne({ _id: ObjectId("507f1f77bcf86cd799439011") });
```

---

## c) Filtering Data and Reports

The application supports extensive filtering capabilities on the Tasks collection. This demonstrates data filtering with range queries and dynamic reports.

### Filtering Example 1: Filter by Estimated Time Range

**Scenario:** Show all tasks that take between 30 and 120 minutes

```javascript
// API Endpoint: GET /api/tasks?minTime=30&maxTime=120

// Backend Code (routes/tasks.js):
const filter = {};
if (req.query.minTime || req.query.maxTime) {
  filter.estimatedTime = {};
  if (req.query.minTime) {
    filter.estimatedTime.$gte = parseInt(req.query.minTime);
  }
  if (req.query.maxTime) {
    filter.estimatedTime.$lte = parseInt(req.query.maxTime);
  }
}
const tasks = await Task.find(filter).populate('classId', 'name');

// MongoDB Command Equivalent:
db.tasks.find({
  estimatedTime: { $gte: 30, $lte: 120 }
});
```

### Filtering Example 2: Multiple Criteria

**Scenario:** Show incomplete, high-priority tasks due between specific dates

```javascript
// API Endpoint: GET /api/tasks?completed=false&priority=high&startDate=2024-01-01&endDate=2024-12-31

// MongoDB Query:
db.tasks.find({
  completed: false,
  priority: "high",
  dueDate: {
    $gte: ISODate("2024-01-01"),
    $lte: ISODate("2024-12-31")
  }
});
```

### Report Display

The frontend displays a **Task Statistics Report** that includes:
- Total Tasks
- Completed Tasks
- Incomplete Tasks
- Total Estimated Time
- Average Estimated Time

**Report Before Data Change:**
```
Task Statistics Report
Total Tasks: 5
Completed Tasks: 2
Incomplete Tasks: 3
Total Estimated Time: 450 minutes
Average Estimated Time: 90 minutes
```

**After marking 2 more tasks as complete (or adding new tasks):**
```
Task Statistics Report
Total Tasks: 5
Completed Tasks: 4
Incomplete Tasks: 1
Total Estimated Time: 450 minutes
Average Estimated Time: 90 minutes
```

The report updates **dynamically** based on:
1. Current filter settings
2. Real-time data from the database
3. Any CRUD operations performed

### Implementation in Frontend (tasks.js):

```javascript
// Calculate statistics for report
const getStats = () => {
  const totalTasks = tasks.length;
  const completedTasks = tasks.filter(t => t.completed).length;
  const totalEstimatedTime = tasks.reduce((sum, t) => sum + (t.estimatedTime || 0), 0);
  const avgEstimatedTime = totalTasks > 0 ? (totalEstimatedTime / totalTasks).toFixed(2) : 0;
  
  return {
    totalTasks,
    completedTasks,
    incompleteTasks: totalTasks - completedTasks,
    totalEstimatedTime,
    avgEstimatedTime
  };
};
```

---

## d) Dynamic User Interface Components

### Dynamic Dropdown List - Course Selection

**Requirement:** The course selection dropdown must be populated dynamically from the database, not hard-coded.

**Implementation in Frontend (tasks.js):**

```javascript
// 1. Fetch all classes from database
const fetchClasses = async () => {
  try {
    const response = await fetch('http://localhost:5000/api/classes');
    const data = await response.json();
    setAllClasses(data);  // Store in state
  } catch (error) {
    console.error('Error fetching classes:', error);
  }
};

// 2. Load classes when component mounts
useEffect(() => {
  fetchClasses();
}, []);

// 3. Dynamically populate dropdown
<select
  name="classId"
  value={formData.classId}
  onChange={handleInputChange}
  required
>
  <option value="">Select a course</option>
  {allClasses.map(c => (
    <option key={c._id} value={c._id}>{c.name}</option>
  ))}
</select>
```

**Backend API Endpoint:**
```javascript
// GET /api/classes
router.get('/', async (req, res) => {
  try {
    const classes = await Class.find().sort({ createdAt: -1 });
    res.json(classes);
  } catch (err) {
    res.status(500).json({ message: err.message });
  }
});
```

**Database Query:**
```javascript
// MongoDB retrieves all classes
db.classes.find().sort({ createdAt: -1 })
```

### How It Works:

1. **Frontend** sends a GET request to `/api/classes`
2. **Backend** queries MongoDB for all classes
3. **Database** returns an array of class documents
4. **Backend** sends JSON response to frontend
5. **Frontend** stores the classes in state
6. **UI Component** maps over the array to create `<option>` elements

**Key Points:**
- ✅ Data comes directly from the database
- ✅ No hard-coded course names in the code
- ✅ Updates automatically when new courses are added
- ✅ Reusable pattern for other dynamic components

### Visual Demonstration:

When you add a new course named "CS350" in the Course Management page:
1. It's saved to the MongoDB `classes` collection
2. When you navigate to the Tasks page
3. The course dropdown is populated via `fetchClasses()` API call
4. "CS350" appears in the dropdown automatically
5. No code changes required!

---

## MongoDB Setup Instructions

To use this application, you need to set up MongoDB:

### Option 1: MongoDB Atlas (Cloud - Recommended)

1. Go to [MongoDB Atlas](https://www.mongodb.com/cloud/atlas)
2. Create a free account
3. Create a new cluster (free tier available)
4. Click "Connect" and get your connection string
5. Replace `your_mongodb_connection_string_here` in `backend/server.js` with your connection string
   - Example: `mongodb+srv://username:password@cluster.mongodb.net/todoapp?retryWrites=true&w=majority`

### Option 2: Local MongoDB

1. Install MongoDB Community Edition from [mongodb.com](https://www.mongodb.com/try/download/community)
2. Start MongoDB service:
   - Windows: `net start MongoDB`
   - Mac/Linux: `sudo systemctl start mongod`
3. Use connection string: `mongodb://localhost:27017/todoapp`
4. Replace in `backend/server.js`

### Running the Application

1. **Install backend dependencies:**
   ```bash
   cd backend
   npm install
   npm start
   ```

2. **Install frontend dependencies:**
   ```bash
   cd frontend
   npm install
   npm run dev
   ```

3. **Access the application:**
   - Frontend: http://localhost:3000
   - Backend API: http://localhost:5000

---

## API Endpoints Summary

### Classes
- `GET /api/classes` - Get all classes
- `GET /api/classes/:id` - Get one class
- `POST /api/classes` - Create a class
- `PUT /api/classes/:id` - Update a class
- `DELETE /api/classes/:id` - Delete a class

### Tasks
- `GET /api/tasks` - Get all tasks (with filtering)
- `GET /api/tasks/:id` - Get one task
- `POST /api/tasks` - Create a task
- `PUT /api/tasks/:id` - Update a task
- `DELETE /api/tasks/:id` - Delete a task

### Task Filtering Parameters:
- `classId` - Filter by class
- `completed` - true/false
- `priority` - low/medium/high
- `minTime` - Minimum estimated time
- `maxTime` - Maximum estimated time
- `startDate` - Due date range start
- `endDate` - Due date range end

